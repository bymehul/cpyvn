# cython: language_level=3
# cython: boundscheck=False
# cython: wraparound=False
# cython: cdivision=True
from __future__ import annotations

import json
import logging
from pathlib import Path
import re
from typing import Dict, Optional, Tuple

import pygame

from ..script import Show
from .script_editor import ScriptEditorMixin
from .state import HotspotArea, HudButton


logger = logging.getLogger("cpyvn.runtime.inspector")


class InspectorMixin(ScriptEditorMixin):
    _AUTO_BLOCK_BEGIN = "# cpyvn-editor begin"
    _AUTO_BLOCK_END   = "# cpyvn-editor end"


    def _fmt_script_num(self, double value):
        cdef str text = f"{value:.3f}".rstrip("0").rstrip(".")
        return text if text else "0"

    def _sprite_script_size(self, object sprite):
        cdef object state = sprite.state
        if state.kind == "rect":
            return sprite.rect.width, sprite.rect.height
        if state.kind != "image":
            return state.size
        cdef object source = sprite.source_surface
        if source is None:
            return state.size
        if state.size is not None or source.get_size() != sprite.rect.size:
            return sprite.rect.width, sprite.rect.height
        return None

    def _sprite_snippet(self, str name, object sprite):
        cdef object st = sprite.state
        cdef int x = sprite.rect.x
        cdef int y = sprite.rect.y
        cdef str z_part = f" z {st.z}" if st.z else ""
        cdef object script_size = self._sprite_script_size(sprite)
        cdef object character, expr
        cdef str key, path, expr_part, size_part

        if st.kind == "rect" and st.size:
            return f"add rect {name} {st.value} {st.size[0]} {st.size[1]} {x} {y}{z_part};"

        character = self.characters.get(name)
        if character and script_size is None:
            expr = None
            if character.sprites:
                for key, path in character.sprites.items():
                    if path == st.value:
                        expr = key if key != "default" else None
                        break
            expr_part = f" {expr}" if expr else ""
            return f"show {name}{expr_part} {x} {y}{z_part};"

        size_part = ""
        if script_size is not None:
            size_part = f" size {script_size[0]} {script_size[1]}"
        return f"add image {name} \"{st.value}\"{size_part} {x} {y}{z_part};"


    def _build_auto_script_block(self):
        cdef list lines = [self._AUTO_BLOCK_BEGIN, "# auto-generated by inspector/hotspot/hud editor"]
        cdef str camera_line, name
        cdef object hotspot, sprite

        camera_line = (
            f"camera {self._fmt_script_num(self.camera_pan_x)} "
            f"{self._fmt_script_num(self.camera_pan_y)} "
            f"{self._fmt_script_num(self.camera_zoom)};"
        )
        lines.append(f"# {camera_line}")

        if self.hotspots:
            lines.append("# hotspots")
            for name in sorted(self.hotspots.keys()):
                hotspot = self.hotspots[name]
                lines.append(f"# {self._hotspot_snippet(hotspot)}")

        if self.sprites:
            lines.append("# sprites")
            for name, sprite in sorted(
                self.sprites.items(), key=lambda item: (item[1].state.z, item[0])
            ):
                lines.append(f"# {self._sprite_snippet(name, sprite)}")

        if self.hud_buttons:
            lines.append("# hud buttons")
            for name in sorted(self.hud_buttons.keys()):
                btn = self.hud_buttons[name]
                lines.append(f"# {self._hud_snippet(btn)}")

        if self.map_active and self.map_points:
            lines.append("# map points")
            for idx, poi in enumerate(self.map_points):
                lines.append(f"# {self._map_poi_snippet(poi)}")

        lines.append(self._AUTO_BLOCK_END)
        return lines

    def _replace_auto_script_block(self, str text, list block_lines):
        cdef str block = "\n".join(block_lines).rstrip() + "\n"
        cdef int start, end, end_line
        cdef str prefix, suffix

        start = text.find(self._AUTO_BLOCK_BEGIN)
        if start != -1:
            end = text.find(self._AUTO_BLOCK_END, start)
            if end != -1:
                end_line = text.find("\n", end)
                if end_line == -1:
                    end_line = len(text)
                else:
                    end_line += 1
                prefix = text[:start].rstrip("\n")
                suffix = text[end_line:]
                if prefix:
                    return f"{prefix}\n\n{block}{suffix}"
                return f"{block}{suffix}"
        cdef str base = text.rstrip("\n")
        if base:
            return f"{base}\n\n{block}"
        return block

    def _auto_sync_script_block(self):
        cdef object target = getattr(self, "current_script_path", None)
        cdef object feature_paths = getattr(self, "feature_script_paths", None)
        cdef object map_target
        cdef object hud_target
        if isinstance(feature_paths, dict):
            if self.map_active or self.map_poi_editor_poly_active:
                map_target = feature_paths.get("maps")
                if isinstance(map_target, Path):
                    target = map_target
            elif self.show_hud_editor:
                hud_target = feature_paths.get("hud")
                if isinstance(hud_target, Path):
                    target = hud_target
        if not isinstance(target, Path):
            return
        target = target.resolve()
        cdef list block_lines = self._build_auto_script_block()
        cdef bint editor_active = (
            self.show_script_editor
            and self.script_editor_path.resolve() == target
        )
        cdef str current_text, updated
        cdef list updated_lines
        cdef object cache

        if editor_active:
            current_text = self._script_editor_text()
            updated = self._replace_auto_script_block(current_text, block_lines)
            if updated != current_text:
                updated_lines = updated.splitlines()
                self.script_editor_lines  = updated_lines if updated_lines else [""]
                self.script_editor_dirty  = True
                self.script_editor_status = "Auto-updated block (Ctrl+S to save)"
                self._script_editor_clamp_cursor()
                self._script_editor_keep_cursor_visible()
            return

        try:
            current_text = target.read_text(encoding="utf-8")
        except OSError:
            return
        updated = self._replace_auto_script_block(current_text, block_lines)
        if updated == current_text:
            return
        try:
            target.write_text(updated, encoding="utf-8")
        except OSError:
            return
        cache = getattr(self, "_script_cache", None)
        if isinstance(cache, dict):
            cache.pop(target, None)


    def _pick_sprite(self, tuple pos):
        cdef str name
        cdef object sprite
        for name, sprite in sorted(
            self.sprites.items(),
            key=lambda item: item[1].state.z,
            reverse=True,
        ):
            if sprite.rect.collidepoint(pos):
                return name
        return None

    def _sync_sprite_state_from_rect(self, object sprite):
        sprite.state.size = self._sprite_script_size(sprite)
        sprite.state.pos = (sprite.rect.x, sprite.rect.y)
        sprite.state.anchor = None

    def _rescale_sprite_surface(self, object sprite, tuple size):
        cdef int width  = max(8, <int>size[0])
        cdef int height = max(8, <int>size[1])
        cdef object source

        if sprite.state.kind == "rect":
            sprite.surface    = self.assets.make_rect_surface(sprite.state.value, (width, height))
            sprite.rect.size  = (width, height)
            return

        source = sprite.source_surface
        if source is None:
            source = self.assets.load_image(sprite.state.value, "sprites").copy()
            sprite.source_surface = source
        if source.get_size() == (width, height):
            sprite.surface = source.copy()
        else:
            sprite.surface = pygame.transform.smoothscale(source, (width, height))
        sprite.rect.size = (width, height)

    def _scale_selected_sprite(self, double factor):
        cdef object sprite
        cdef object old_rect
        cdef int width, height
        cdef object new_rect

        if not self.inspector_selected or factor <= 0:
            return False
        sprite = self.sprites.get(self.inspector_selected)
        if sprite is None:
            return False
        old_rect = sprite.rect.copy()
        width  = max(8, <int>round(old_rect.width  * factor))
        height = max(8, <int>round(old_rect.height * factor))
        if width == old_rect.width and height == old_rect.height:
            return False
        new_rect        = pygame.Rect(0, 0, width, height)
        new_rect.center = old_rect.center
        sprite.rect     = new_rect
        self._rescale_sprite_surface(sprite, (width, height))
        self._sync_sprite_state_from_rect(sprite)
        return True

    def _nudge_selected_sprite(self, int dx, int dy):
        cdef object sprite
        if not self.inspector_selected:
            return False
        sprite = self.sprites.get(self.inspector_selected)
        if sprite is None:
            return False
        if dx == 0 and dy == 0:
            return False
        sprite.rect.x += dx
        sprite.rect.y += dy
        self._sync_sprite_state_from_rect(sprite)
        return True


    def _inspector_handle_rects(self, object rect):
        cdef int size = 12
        cdef int half = size // 2
        return {
            "nw": pygame.Rect(rect.left  - half, rect.top    - half, size, size),
            "ne": pygame.Rect(rect.right - half, rect.top    - half, size, size),
            "sw": pygame.Rect(rect.left  - half, rect.bottom - half, size, size),
            "se": pygame.Rect(rect.right - half, rect.bottom - half, size, size),
        }

    def _inspector_handle_at(self, tuple pos):
        cdef str name
        cdef object rect
        if not self.inspector_selected:
            return None
        sprite = self.sprites.get(self.inspector_selected)
        if sprite is None:
            return None
        for name, rect in self._inspector_handle_rects(sprite.rect).items():
            if rect.collidepoint(pos):
                return name
        return None

    def _inspector_resize_rect(
        self,
        object start_rect,
        tuple  start_mouse,
        tuple  now_mouse,
        str    handle,
        bint   keep_ratio,
    ):
        cdef int min_size = 8
        cdef double left   = <double>start_rect.left
        cdef double top    = <double>start_rect.top
        cdef double right  = <double>start_rect.right
        cdef double bottom = <double>start_rect.bottom
        cdef double dx = <double>(now_mouse[0] - start_mouse[0])
        cdef double dy = <double>(now_mouse[1] - start_mouse[1])
        cdef double aspect
        cdef int width, height
        cdef bint anchor_left, anchor_top

        if "w" in handle: left   += dx
        if "e" in handle: right  += dx
        if "n" in handle: top    += dy
        if "s" in handle: bottom += dy

        if "w" in handle and left  > right  - min_size: left  = right  - min_size
        if "e" in handle and right < left   + min_size: right = left   + min_size
        if "n" in handle and top   > bottom - min_size: top   = bottom - min_size
        if "s" in handle and bottom < top   + min_size: bottom = top   + min_size

        if keep_ratio:
            aspect = start_rect.width / max(1, start_rect.height)
            width  = max(min_size, <int>round(right  - left))
            height = max(min_size, <int>round(bottom - top))
            if abs(dx) >= abs(dy):
                height = max(min_size, <int>round(width / aspect))
            else:
                width  = max(min_size, <int>round(height * aspect))
            anchor_left = "e" not in handle
            anchor_top  = "s" not in handle
            if anchor_left: left  = right  - width
            else:           right = left   + width
            if anchor_top:  top   = bottom - height
            else:           bottom = top   + height

        width  = max(min_size, <int>round(right  - left))
        height = max(min_size, <int>round(bottom - top))
        return pygame.Rect(<int>round(left), <int>round(top), width, height)


    def _inspector_asset_panel_rect(self):
        cdef int sw = self.screen.get_width()
        cdef int sh = self.screen.get_height()
        cdef int panel_w = min(420, max(260, <int>(sw * 0.32)))
        cdef int panel_h = min(sh - 56, max(240, <int>(sh * 0.62)))
        return pygame.Rect(sw - panel_w - 10, 42, panel_w, panel_h)

    def _inspector_asset_row_height(self):
        return self.inspector_font.get_height() + 6

    def _inspector_asset_visible_rows(self):
        cdef object panel = self._inspector_asset_panel_rect()
        cdef int row_h   = self._inspector_asset_row_height()
        cdef int list_top = panel.y + 60
        cdef int list_h   = panel.bottom - list_top - 8
        return max(1, list_h // row_h)

    def _inspector_clamp_asset_scroll(self):
        cdef int rows       = self._inspector_asset_visible_rows()
        cdef int max_scroll = max(0, len(self.inspector_asset_entries) - rows)
        self.inspector_asset_scroll = max(0, min(max_scroll, self.inspector_asset_scroll))

    def _inspector_keep_asset_visible(self):
        cdef int rows = self._inspector_asset_visible_rows()
        if self.inspector_asset_selected < self.inspector_asset_scroll:
            self.inspector_asset_scroll = self.inspector_asset_selected
        elif self.inspector_asset_selected >= self.inspector_asset_scroll + rows:
            self.inspector_asset_scroll = self.inspector_asset_selected - rows + 1
        self._inspector_clamp_asset_scroll()

    def _refresh_inspector_asset_entries(self):
        cdef object sprites_root = self.assets.asset_dirs.get("sprites", self.assets.project_root)
        cdef set exts = {".png", ".jpg", ".jpeg", ".webp", ".bmp", ".gif"}
        cdef list files = []
        cdef object path
        cdef str rel

        if sprites_root.exists():
            for path in sprites_root.rglob("*"):
                if not path.is_file():
                    continue
                if path.suffix.lower() not in exts:
                    continue
                try:
                    rel = path.relative_to(sprites_root).as_posix()
                except ValueError:
                    rel = path.name
                files.append(rel)
        files.sort()
        self.inspector_asset_entries = files
        if not files:
            self.inspector_asset_selected = 0
            self.inspector_asset_scroll   = 0
            return
        if self.inspector_asset_selected >= len(files):
            self.inspector_asset_selected = len(files) - 1
        self._inspector_keep_asset_visible()

    def _toggle_inspector_asset_mode(self):
        self.inspector_asset_mode    = not self.inspector_asset_mode
        self.inspector_asset_buttons = {}
        if self.inspector_asset_mode:
            self._refresh_inspector_asset_entries()

    def _next_editor_sprite_name(self, str rel_path):
        cdef str stem = re.sub(r"[^0-9A-Za-z_]+", "_", Path(rel_path).stem).strip("_").lower()
        cdef str name
        cdef int idx

        if not stem:
            stem = "sprite"
        if stem[0].isdigit():
            stem = f"s_{stem}"
        name = stem
        idx  = 2
        while name in self.sprites or name in self.characters:
            name = f"{stem}_{idx}"
            idx += 1
        return name

    def _add_selected_asset_sprite(self):
        cdef int index
        cdef str rel_path
        cdef object image
        cdef str name
        cdef int z, x, y

        if not self.inspector_asset_entries:
            return False
        index    = max(0, min(len(self.inspector_asset_entries) - 1, self.inspector_asset_selected))
        rel_path = self.inspector_asset_entries[index]
        image    = self.assets.load_image(rel_path, "sprites")
        name     = self._next_editor_sprite_name(rel_path)
        z        = max((sprite.state.z for sprite in self.sprites.values()), default=0) + 1
        x        = (self.screen.get_width()  - image.get_width())  // 2
        y        = self.screen.get_height() - self.textbox.box_height - 20 - image.get_height()
        if y < 0:
            y = (self.screen.get_height() - image.get_height()) // 2
        self._apply_show(Show(kind="image", name=name, value=rel_path, pos=(x, y), z=z))
        self.inspector_selected         = name
        self.inspector_dragging         = False
        self.inspector_resizing         = False
        self.inspector_resize_handle    = None
        self.inspector_resize_start_rect = None
        self._save_inspector_state()
        return True

    def _adjust_selected_z(self, int delta):
        cdef object sprite
        if not self.inspector_selected:
            return
        sprite = self.sprites.get(self.inspector_selected)
        if not sprite:
            return
        sprite.state.z = sprite.state.z + delta
        self._auto_sync_script_block()


    def _handle_inspector_keydown(self, object event):
        cdef int key  = event.key
        cdef int mods = pygame.key.get_mods()
        cdef int step = 10 if (mods & pygame.KMOD_SHIFT) else 1

        if key == pygame.K_a:
            self._toggle_inspector_asset_mode()
            return True
        if key == pygame.K_c:
            self._print_inspector_snippet()
            return True
        if key == pygame.K_LEFTBRACKET:
            self._adjust_selected_z(-1)
            self._save_inspector_state()
            return True
        if key == pygame.K_RIGHTBRACKET:
            self._adjust_selected_z(1)
            self._save_inspector_state()
            return True
        if self.inspector_asset_mode and key == pygame.K_r:
            self._refresh_inspector_asset_entries()
            return True
        if self.inspector_asset_mode and key in (pygame.K_RETURN, pygame.K_KP_ENTER):
            self._add_selected_asset_sprite()
            return True
        if self.inspector_asset_mode and key == pygame.K_UP and self.inspector_asset_entries:
            self.inspector_asset_selected = max(0, self.inspector_asset_selected - 1)
            self._inspector_keep_asset_visible()
            return True
        if self.inspector_asset_mode and key == pygame.K_DOWN and self.inspector_asset_entries:
            self.inspector_asset_selected = min(
                len(self.inspector_asset_entries) - 1,
                self.inspector_asset_selected + 1,
            )
            self._inspector_keep_asset_visible()
            return True
        if key == pygame.K_LEFT  and self._nudge_selected_sprite(-step,  0): self._save_inspector_state(); return True
        if key == pygame.K_RIGHT and self._nudge_selected_sprite( step,  0): self._save_inspector_state(); return True
        if key == pygame.K_UP    and self._nudge_selected_sprite(0, -step):  self._save_inspector_state(); return True
        if key == pygame.K_DOWN  and self._nudge_selected_sprite(0,  step):  self._save_inspector_state(); return True
        return False

    def _inspector_button_at(self, tuple pos):
        cdef str name
        cdef object rect
        for name, rect in self.inspector_asset_buttons.items():
            if rect.collidepoint(pos):
                return name
        return None

    def _handle_inspector_mousedown(self, object event):
        cdef double scale
        cdef object action
        cdef int idx
        cdef str handle
        cdef object selected, sprite

        if event.button in (4, 5):
            scale = 1.08 if event.button == 4 else (1.0 / 1.08)
            if self._scale_selected_sprite(scale):
                self._save_inspector_state()
            return True
        if event.button != 1:
            return False

        if self.inspector_asset_mode:
            action = self._inspector_button_at(event.pos)
            if action is not None:
                if action == "asset_add":
                    self._add_selected_asset_sprite()
                elif action == "asset_refresh":
                    self._refresh_inspector_asset_entries()
                elif action == "asset_close":
                    self.inspector_asset_mode    = False
                    self.inspector_asset_buttons = {}
                elif action.startswith("asset_row:"):
                    try:
                        idx = int(action.split(":", 1)[1])
                    except ValueError:
                        idx = -1
                    if 0 <= idx < len(self.inspector_asset_entries):
                        self.inspector_asset_selected = idx
                        self._inspector_keep_asset_visible()
                return True

        handle = self._inspector_handle_at(event.pos)
        if handle and self.inspector_selected:
            sprite = self.sprites.get(self.inspector_selected)
            if sprite is None:
                return True
            self.inspector_resizing           = True
            self.inspector_resize_handle      = handle
            self.inspector_resize_start_rect  = sprite.rect.copy()
            self.inspector_resize_start_mouse = event.pos
            self.inspector_dragging           = False
            return True

        selected = self._pick_sprite(event.pos)
        self.inspector_selected  = selected
        self.inspector_resizing  = False
        self.inspector_resize_handle     = None
        self.inspector_resize_start_rect = None
        if selected:
            sprite = self.sprites[selected]
            self.inspector_dragging   = True
            self.inspector_drag_offset = (
                event.pos[0] - sprite.rect.x,
                event.pos[1] - sprite.rect.y,
            )
        else:
            self.inspector_dragging = False
        return True

    def _handle_inspector_mousemotion(self, object event):
        cdef object sprite, new_rect
        cdef bint keep_ratio

        if not self.inspector_selected:
            return False
        sprite = self.sprites.get(self.inspector_selected)
        if sprite is None:
            return False

        if (
            self.inspector_resizing
            and self.inspector_resize_start_rect is not None
            and self.inspector_resize_handle
        ):
            keep_ratio = bool(pygame.key.get_mods() & pygame.KMOD_SHIFT)
            new_rect   = self._inspector_resize_rect(
                self.inspector_resize_start_rect,
                self.inspector_resize_start_mouse,
                event.pos,
                self.inspector_resize_handle,
                keep_ratio,
            )
            if new_rect.size != sprite.rect.size or new_rect.topleft != sprite.rect.topleft:
                sprite.rect = new_rect
                self._rescale_sprite_surface(sprite, new_rect.size)
                self._sync_sprite_state_from_rect(sprite)
            return True

        if self.inspector_dragging:
            sprite.rect.x = event.pos[0] - self.inspector_drag_offset[0]
            sprite.rect.y = event.pos[1] - self.inspector_drag_offset[1]
            self._sync_sprite_state_from_rect(sprite)
            return True

        return False

    def _handle_inspector_mouseup(self, object event):
        cdef bint changed
        if event.button != 1:
            return False
        changed = self.inspector_dragging or self.inspector_resizing
        self.inspector_dragging          = False
        self.inspector_resizing          = False
        self.inspector_resize_handle     = None
        self.inspector_resize_start_rect = None
        if changed:
            self._save_inspector_state()
            return True
        return False

    def _handle_inspector_mousewheel(self, int wheel_y):
        cdef object panel
        if wheel_y == 0:
            return False
        if self.inspector_asset_mode:
            panel = self._inspector_asset_panel_rect()
            if panel.collidepoint(pygame.mouse.get_pos()):
                self.inspector_asset_scroll -= wheel_y
                self._inspector_clamp_asset_scroll()
                return True
        if self._scale_selected_sprite(1.08 ** wheel_y):
            self._save_inspector_state()
            return True
        return False

    def _print_inspector_snippet(self):
        cdef object sprite
        cdef str snippet
        if not self.inspector_selected:
            return
        sprite = self.sprites.get(self.inspector_selected)
        if not sprite:
            return
        snippet = self._sprite_snippet(self.inspector_selected, sprite)
        print(f"[INSPECTOR] {snippet}")


    def _draw_inspector_asset_panel(self):
        cdef object panel = self._inspector_asset_panel_rect()
        cdef object overlay = pygame.Surface((panel.width, panel.height), pygame.SRCALPHA)
        overlay.fill((10, 10, 12, 225))
        self.screen.blit(overlay, panel.topleft)
        pygame.draw.rect(self.screen, (140, 140, 160), panel, 1)

        cdef object title = self.inspector_font.render("Placement Mode (A)", True, (245, 245, 245))
        self.screen.blit(title, (panel.x + 10, panel.y + 8))

        self.inspector_asset_buttons = {}
        cdef object add_rect     = pygame.Rect(panel.x + 10,       panel.y + 28, 58, 22)
        cdef object refresh_rect = pygame.Rect(panel.x + 74,       panel.y + 28, 78, 22)
        cdef object close_rect   = pygame.Rect(panel.right - 60,   panel.y + 28, 50, 22)
        self.inspector_asset_buttons["asset_add"]     = add_rect
        self.inspector_asset_buttons["asset_refresh"] = refresh_rect
        self.inspector_asset_buttons["asset_close"]   = close_rect
        cdef object rect, txt
        cdef str label
        for rect, label in ((add_rect, "Add"), (refresh_rect, "Refresh"), (close_rect, "Close")):
            pygame.draw.rect(self.screen, (64, 86, 120), rect, border_radius=4)
            pygame.draw.rect(self.screen, (220, 220, 220), rect, 1, border_radius=4)
            txt = self.inspector_font.render(label, True, (250, 250, 250))
            self.screen.blit(txt, (rect.x + 6, rect.y + 3))

        cdef int list_top     = panel.y + 60
        cdef int row_h        = self._inspector_asset_row_height()
        cdef int visible_rows = self._inspector_asset_visible_rows()
        cdef object msg
        self._inspector_clamp_asset_scroll()

        if not self.inspector_asset_entries:
            msg = self.inspector_font.render(
                "No images found in assets/sprites", True, (220, 160, 160)
            )
            self.screen.blit(msg, (panel.x + 10, list_top + 6))
            return

        cdef int row, idx, y
        cdef object row_rect
        cdef bint selected_row
        for row in range(visible_rows):
            idx = self.inspector_asset_scroll + row
            if idx >= len(self.inspector_asset_entries):
                break
            y        = list_top + row * row_h
            row_rect = pygame.Rect(panel.x + 8, y, panel.width - 16, row_h - 1)
            self.inspector_asset_buttons[f"asset_row:{idx}"] = row_rect
            selected_row = idx == self.inspector_asset_selected
            if selected_row:
                pygame.draw.rect(self.screen, (88, 124, 174), row_rect, border_radius=3)
            elif row % 2 == 0:
                pygame.draw.rect(self.screen, (24, 24, 30), row_rect)
            label = self.inspector_asset_entries[idx]
            txt   = self.inspector_font.render(
                label, True, (248, 248, 248) if selected_row else (215, 215, 215)
            )
            self.screen.blit(txt, (row_rect.x + 6, row_rect.y + 2))


    def _draw_inspector(self):
        cdef str help_text = (
            "Inspector(F3): drag | corner resize (Shift keep ratio) | "
            "wheel scale | arrows nudge | [/] z | C copy | A assets"
        )
        cdef object help_surf = self.inspector_font.render(help_text, True, (240, 240, 240))
        self.screen.blit(help_surf, (8, 8))
        cdef str mode_text = "Placement panel: ON" if self.inspector_asset_mode else "Placement panel: OFF"
        cdef object mode_surf = self.inspector_font.render(mode_text, True, (220, 220, 180))
        self.screen.blit(mode_surf, (8, 26))

        cdef str name
        cdef object sprite, color, text, rect
        for name, sprite in self.sprites.items():
            color = (255, 120, 80) if name == self.inspector_selected else (120, 180, 255)
            pygame.draw.rect(self.screen, color, sprite.rect, 1)
            label = (
                f"{name} ({sprite.rect.x},{sprite.rect.y}) "
                f"{sprite.rect.width}x{sprite.rect.height} z{sprite.state.z}"
            )
            text = self.inspector_font.render(label, True, color)
            self.screen.blit(text, (sprite.rect.x, max(0, sprite.rect.y - text.get_height() - 2)))
            if name == self.inspector_selected:
                for rect in self._inspector_handle_rects(sprite.rect).values():
                    pygame.draw.rect(self.screen, (255, 200, 120), rect)
                    pygame.draw.rect(self.screen, (20, 20, 20),    rect, 1)

        if self.inspector_asset_mode:
            self._draw_inspector_asset_panel()
        else:
            self.inspector_asset_buttons = {}

    def _save_inspector_state(self):
        cdef dict data = {}
        cdef str name
        cdef object sprite, script_size

        for name, sprite in self.sprites.items():
            script_size  = self._sprite_script_size(sprite)
            data[name] = {
                "x":    sprite.rect.x,
                "y":    sprite.rect.y,
                "w":    sprite.rect.width,
                "h":    sprite.rect.height,
                "z":    sprite.state.z,
                "kind": sprite.state.kind,
                "size": list(script_size) if script_size is not None else None,
                "value": sprite.state.value,
            }
        try:
            self.inspector_path.parent.mkdir(parents=True, exist_ok=True)
            self.inspector_path.write_text(json.dumps(data, indent=2), encoding="utf-8")
        except OSError:
            pass
        self._auto_sync_script_block()


    def _toggle_debug_menu(self):
        if not self.map_active:
            self.show_debug_menu = False
            return
        self.show_debug_menu = not self.show_debug_menu
        if self.show_debug_menu:
            self.show_inspector = False
            self.show_hotspot_editor = False
            self.show_hud_editor = False
            self.show_script_editor = False
            self.map_poi_editor_poly_active = False
            self.map_poi_editor_poly_points = []
            self.hotspot_debug = True # Show existing hotspots
        else:
            self.hotspot_debug = False


    def _toggle_hotspot_editor(self):
        self.show_hotspot_editor = not self.show_hotspot_editor
        if self.show_hotspot_editor:
            self.show_inspector              = False
            self.inspector_selected          = None
            self.inspector_dragging          = False
            self.inspector_resizing          = False
            self.inspector_resize_handle     = None
            self.inspector_resize_start_rect = None
            self.inspector_asset_mode        = False
            self.inspector_asset_buttons     = {}
            self.hotspot_debug               = True
            self.hotspot_editor_mode         = "select"
            self.hotspot_editor_drag_start   = None
            self.hotspot_editor_preview_points = []
            self.hotspot_editor_poly_points  = []
            self.hotspot_editor_buttons      = {}
        else:
            self.hotspot_editor_drag_start     = None
            self.hotspot_editor_preview_points = []
            self.hotspot_editor_poly_points    = []
            self.hotspot_editor_buttons        = {}
            self.hotspot_hovered               = None

    def _draw_debug_menu(self):
        cdef object panel = pygame.Surface((self.screen.get_width(), 120), pygame.SRCALPHA)
        panel.fill((20, 20, 30, 200))
        self.screen.blit(panel, (0, 0))

        cdef object title_surf = self.inspector_font.render(
            "Debug Menu (Ctrl+M): Camera Control | Hotspot Tools",
            True, (255, 255, 255),
        )
        self.screen.blit(title_surf, (10, 8))

        # Camera info
        cdef str cam_info = f"Camera: Pan ({self.camera_pan_x:.1f}, {self.camera_pan_y:.1f}) | Zoom: {self.camera_zoom:.2f}"
        cdef object cam_surf = self.inspector_font.render(cam_info, True, (200, 255, 200))
        self.screen.blit(cam_surf, (10, 30))

        cdef list buttons = []
        if self.map_active:
            buttons.append(("add_poi", "Add Map POI"))
            buttons.append(("add_map_poly", "Add Map Poly"))

        self.debug_menu_buttons = {}
        cdef int x = 10, y = 55, bw
        cdef str key, label
        cdef object rect, txt
        for key, label in buttons:
            bw = 100
            rect = pygame.Rect(x, y, bw, 25)
            self.debug_menu_buttons[key] = rect
            pygame.draw.rect(self.screen, (60, 60, 80), rect, border_radius=4)
            pygame.draw.rect(self.screen, (200, 200, 200), rect, 1, border_radius=4)
            txt = self.inspector_font.render(label, True, (255, 255, 255))
            self.screen.blit(txt, (rect.x + 8, rect.y + 5))
            x += bw + 10

        cdef str status = "Map editor: click to add point POI."
        cdef str hint = "Use Add Map Poly for polygon mode."
        if self.map_poi_editor_poly_active:
            status = (
                f"Polygon: {len(self.map_poi_editor_poly_points)} points. "
                "Press Enter or right-click to save."
            )
            hint = "Left click adds polygon vertices."
        elif self.show_hotspot_editor and self.hotspot_editor_mode == "poly":
             status = (
                 f"Hotspot Poly: {len(self.hotspot_editor_poly_points)} points. "
                 "Press Enter or right-click to save."
             )
             hint = "Left click adds polygon vertices."
             
        cdef object status_surf = self.inspector_font.render(status, True, (255, 255, 0))
        self.screen.blit(status_surf, (10, 85))
        cdef object hint_surf = self.inspector_font.render(hint, True, (200, 220, 255))
        self.screen.blit(hint_surf, (10, 102))

        # Draw preview points for map poly
        if self.map_poi_editor_poly_active and self.map_poi_editor_poly_points:
            if len(self.map_poi_editor_poly_points) > 1:
                pygame.draw.lines(self.screen, (255, 255, 0), False, self.map_poi_editor_poly_points, 2)
            for pt in self.map_poi_editor_poly_points:
                pygame.draw.circle(self.screen, (255, 255, 255), pt, 4)

    def _handle_debug_menu_mousedown(self, object event):
        cdef tuple world, mouse_pos
        cdef str key
        cdef object rect
        
        mouse_pos = event.pos
        # Check buttons
        for key, rect in self.debug_menu_buttons.items():
            if rect.collidepoint(mouse_pos):
                if key == "add_poi":
                    self.map_poi_editor_poly_active = False
                elif key == "add_map_poly":
                    self.map_poi_editor_poly_active = True
                    self.map_poi_editor_poly_points = []
                return

        if self.map_active:
            if self.map_poi_editor_poly_active:
                self.map_poi_editor_poly_points.append(mouse_pos)
                return

            # Add a single-point POI at world position
            world = self._screen_to_bg_world(mouse_pos)
            self.map_points.append({
                "label": "New POI",
                "pos": (int(world[0]), int(world[1])),
                "points": [],
                "target": "::start"
            })
            self._auto_sync_script_block()
            logger.info("Added Map POI at %s", world)

    def _handle_debug_menu_rightclick(self, object event):
        cdef tuple world_pos
        cdef list world_points
        if self.map_poi_editor_poly_active and self.map_poi_editor_poly_points:
            if len(self.map_poi_editor_poly_points) < 2:
                self.map_poi_editor_poly_active = False
                self.map_poi_editor_poly_points = []
                return
            
            # Finish polygon POI
            # We take the first point as the 'pos' for labeling
            world_pos = self._screen_to_bg_world(self.map_poi_editor_poly_points[0])
            world_points = [self._screen_to_bg_world(pt) for pt in self.map_poi_editor_poly_points]
            
            self.map_points.append({
                "label": "New Poly POI",
                "pos": (int(world_pos[0]), int(world_pos[1])),
                "points": world_points,
                "target": "::start"
            })
            self.map_poi_editor_poly_active = False
            self.map_poi_editor_poly_points = []
            self._auto_sync_script_block()
            logger.info("Added Polygon Map POI with %d points", len(world_points))

    def _cancel_hotspot_editor_action(self):
        if not self.show_hotspot_editor:
            return False
        if self.hotspot_editor_drag_start is not None:
            self.hotspot_editor_drag_start     = None
            self.hotspot_editor_preview_points = []
            return True
        if self.hotspot_editor_poly_points:
            self.hotspot_editor_poly_points = []
            return True
        self._toggle_hotspot_editor()
        return True

    def _set_hotspot_editor_mode(self, str mode):
        if mode not in {"select", "rect", "poly"}:
            return
        self.hotspot_editor_mode         = mode
        self.hotspot_editor_drag_start   = None
        self.hotspot_editor_preview_points = []
        if mode != "poly":
            self.hotspot_editor_poly_points = []

    def _cycle_hotspot_editor_mode(self):
        cdef list order = ["select", "rect", "poly"]
        cdef int idx
        try:
            idx = order.index(self.hotspot_editor_mode)
        except ValueError:
            idx = 0
        self._set_hotspot_editor_mode(order[(idx + 1) % 3])

    def _next_hotspot_name(self):
        cdef int idx = 1
        cdef str name
        while True:
            name = f"hs_{idx}"
            if name not in self.hotspots:
                return name
            idx += 1

    def _hotspot_rect_points(self, tuple a, tuple b):
        cdef int x1 = min(a[0], b[0])
        cdef int y1 = min(a[1], b[1])
        cdef int x2 = max(a[0], b[0])
        cdef int y2 = max(a[1], b[1])
        return [(x1, y1), (x2, y1), (x2, y2), (x1, y2)]

    def _hotspot_bounds(self, list points):
        cdef int min_x = min(point[0] for point in points)
        cdef int max_x = max(point[0] for point in points)
        cdef int min_y = min(point[1] for point in points)
        cdef int max_y = max(point[1] for point in points)
        return min_x, min_y, max_x - min_x, max_y - min_y

    def _hotspot_is_axis_rect(self, list points):
        if len(points) != 4:
            return False
        cdef list xs = sorted(set(point[0] for point in points))
        cdef list ys = sorted(set(point[1] for point in points))
        if len(xs) != 2 or len(ys) != 2:
            return False
        expected = {(xs[0], ys[0]), (xs[1], ys[0]), (xs[1], ys[1]), (xs[0], ys[1])}
        return set(points) == expected

    def _hotspot_snippet(self, object hotspot):
        cdef int x, y, w, h
        cdef list coord_tokens
        cdef int px, py
        if self._hotspot_is_axis_rect(hotspot.points):
            x, y, w, h = self._hotspot_bounds(hotspot.points)
            return f"hotspot add {hotspot.name} {x} {y} {w} {h} -> {hotspot.target};"
        coord_tokens = []
        for px, py in hotspot.points:
            coord_tokens.append(str(px))
            coord_tokens.append(str(py))
        return f"hotspot poly {hotspot.name} {' '.join(coord_tokens)} -> {hotspot.target};"

    def _map_poi_snippet(self, dict poi):
        # map poi "<label>" <x1> <y1> ... -> <target>
        cdef str label = poi.get("label", "POI")
        cdef list points = poi.get("points", [])
        cdef str target = poi.get("target", "::start")
        
        if len(points) > 1:
            coord_tokens = [str(p) for pt in points for p in pt]
            return f"map poi \"{label}\" {' '.join(coord_tokens)} -> {target};"
        else:
            px, py = poi.get("pos", (0, 0))
            return f"map poi \"{label}\" {px} {py} -> {target};"

    def _print_hotspot_snippet(self, str name):
        cdef object hotspot = self.hotspots.get(name)
        if hotspot is None:
            return
        print(f"[HOTSPOT] {self._hotspot_snippet(hotspot)}")

    def _print_all_hotspot_snippets(self):
        cdef object hotspot
        print("[HOTSPOT] --- begin ---")
        for hotspot in self.hotspots.values():
            print(f"[HOTSPOT] {self._hotspot_snippet(hotspot)}")
        print("[HOTSPOT] --- end ---")

    def _shift_hotspot(self, str name, int dx, int dy):
        cdef object hotspot = self.hotspots.get(name)
        if hotspot is None:
            return
        cdef list points = [(px + dx, py + dy) for px, py in hotspot.points]
        self.hotspots[name] = HotspotArea(name=hotspot.name, points=points, target=hotspot.target)
        self._auto_sync_script_block()

    def _cycle_hotspot_target(self, str name):
        cdef object hotspot = self.hotspots.get(name)
        if hotspot is None or not self.labels:
            return
        cdef list label_names = sorted(self.labels.keys())
        cdef int next_idx
        if hotspot.target in label_names:
            next_idx = (label_names.index(hotspot.target) + 1) % len(label_names)
        else:
            next_idx = 0
        cdef str target = label_names[next_idx]
        self.hotspots[name] = HotspotArea(
            name=hotspot.name, points=list(hotspot.points), target=target
        )
        self._print_hotspot_snippet(name)
        self._auto_sync_script_block()

    def _finalize_poly_hotspot(self):
        if len(self.hotspot_editor_poly_points) < 3:
            return
        cdef str name     = self._next_hotspot_name()
        cdef list points  = list(self.hotspot_editor_poly_points)
        self.hotspots[name] = HotspotArea(
            name=name, points=points, target=self.hotspot_editor_default_target
        )
        self.hotspot_editor_selected    = name
        self.hotspot_editor_poly_points = []
        self._print_hotspot_snippet(name)
        self._auto_sync_script_block()


    def _handle_hotspot_editor_keydown(self, object event):
        cdef int key  = event.key
        cdef int mods = pygame.key.get_mods()
        cdef int step = 10 if (mods & pygame.KMOD_SHIFT) else 1

        if key == pygame.K_TAB:
            self._cycle_hotspot_editor_mode(); return
        if key in (pygame.K_1, pygame.K_KP1):
            self._set_hotspot_editor_mode("select"); return
        if key in (pygame.K_2, pygame.K_KP2):
            self._set_hotspot_editor_mode("rect"); return
        if key in (pygame.K_3, pygame.K_KP3):
            self._set_hotspot_editor_mode("poly"); return
        if key == pygame.K_RETURN and self.hotspot_editor_mode == "poly":
            self._finalize_poly_hotspot(); return
        if key in (pygame.K_BACKSPACE, pygame.K_DELETE):
            if self.hotspot_editor_selected:
                self.hotspots.pop(self.hotspot_editor_selected, None)
                self.hotspot_editor_selected = None
                self.hotspot_hovered         = None
                self._auto_sync_script_block()
            return
        if key == pygame.K_c:
            if self.hotspot_editor_selected:
                self._print_hotspot_snippet(self.hotspot_editor_selected)
            return
        if key == pygame.K_p:
            self._print_all_hotspot_snippets(); return
        if key == pygame.K_t and self.hotspot_editor_selected:
            self._cycle_hotspot_target(self.hotspot_editor_selected); return
        if key == pygame.K_r:
            self.camera_pan_x = 0.0
            self.camera_pan_y = 0.0
            self.camera_zoom  = 1.0
            self._auto_sync_script_block(); return

        if key == pygame.K_LEFT:
            if self.hotspot_editor_selected: self._shift_hotspot(self.hotspot_editor_selected, -step, 0)
            else: self.camera_pan_x -= step; self._auto_sync_script_block()
            return
        if key == pygame.K_RIGHT:
            if self.hotspot_editor_selected: self._shift_hotspot(self.hotspot_editor_selected, step, 0)
            else: self.camera_pan_x += step; self._auto_sync_script_block()
            return
        if key == pygame.K_UP:
            if self.hotspot_editor_selected: self._shift_hotspot(self.hotspot_editor_selected, 0, -step)
            else: self.camera_pan_y -= step; self._auto_sync_script_block()
            return
        if key == pygame.K_DOWN:
            if self.hotspot_editor_selected: self._shift_hotspot(self.hotspot_editor_selected, 0, step)
            else: self.camera_pan_y += step; self._auto_sync_script_block()
            return
        if key in (pygame.K_EQUALS, pygame.K_PLUS):
            self.camera_zoom = min(8.0, self.camera_zoom * 1.1)
            self._auto_sync_script_block(); return
        if key == pygame.K_MINUS:
            self.camera_zoom = max(0.1, self.camera_zoom / 1.1)
            self._auto_sync_script_block(); return

    def _editor_button_at(self, tuple pos):
        cdef str name
        cdef object rect
        for name, rect in self.hotspot_editor_buttons.items():
            if rect.collidepoint(pos):
                return name
        return None

    def _handle_hotspot_editor_mousedown(self, object event):
        cdef tuple pos = event.pos
        cdef object action, world
        cdef int idx

        if event.button in (4, 5):
            if event.button == 4:
                self.camera_zoom = min(8.0, self.camera_zoom * 1.08)
            else:
                self.camera_zoom = max(0.1, self.camera_zoom / 1.08)
            self._auto_sync_script_block()
            return

        if event.button == 1:
            action = self._editor_button_at(pos)
            if action:
                if action == "mode_select":  self._set_hotspot_editor_mode("select")
                elif action == "mode_rect":  self._set_hotspot_editor_mode("rect")
                elif action == "mode_poly":  self._set_hotspot_editor_mode("poly")
                elif action == "poly_done":  self._finalize_poly_hotspot()
                elif action == "copy":
                    if self.hotspot_editor_selected:
                        self._print_hotspot_snippet(self.hotspot_editor_selected)
                elif action == "delete":
                    if self.hotspot_editor_selected:
                        self.hotspots.pop(self.hotspot_editor_selected, None)
                        self.hotspot_hovered         = None
                        self.hotspot_editor_selected = None
                        self._auto_sync_script_block()
                elif action == "clear":
                    self.hotspots.clear()
                    self.hotspot_hovered               = None
                    self.hotspot_editor_selected       = None
                    self.hotspot_editor_poly_points    = []
                    self.hotspot_editor_preview_points = []
                    self.hotspot_editor_drag_start     = None
                    self._auto_sync_script_block()
                return

            world = self._screen_to_bg_world(pos)
            if self.hotspot_editor_mode == "select":
                hotspot = self._find_hotspot(pos)
                self.hotspot_editor_selected = hotspot.name if hotspot else None
                self.hotspot_hovered         = self.hotspot_editor_selected
                return
            if self.hotspot_editor_mode == "rect":
                self.hotspot_editor_drag_start     = world
                self.hotspot_editor_preview_points = self._hotspot_rect_points(world, world)
                return
            if self.hotspot_editor_mode == "poly":
                self.hotspot_editor_poly_points.append(world)
                return

        if event.button == 3:
            if self.hotspot_editor_mode == "poly" and self.hotspot_editor_poly_points:
                self.hotspot_editor_poly_points.pop()

    def _handle_hotspot_editor_mousemotion(self, object event):
        cdef object hotspot
        if self.hotspot_editor_mode == "rect" and self.hotspot_editor_drag_start is not None:
            world = self._screen_to_bg_world(event.pos)
            self.hotspot_editor_preview_points = self._hotspot_rect_points(
                self.hotspot_editor_drag_start, world
            )
            return
        hotspot              = self._find_hotspot(event.pos)
        self.hotspot_hovered = hotspot.name if hotspot else None

    def _handle_hotspot_editor_mouseup(self, object event):
        cdef tuple world
        cdef int x, y, w, h
        cdef list points
        cdef str name

        if event.button != 1:
            return
        if self.hotspot_editor_mode != "rect" or self.hotspot_editor_drag_start is None:
            return
        world  = self._screen_to_bg_world(event.pos)
        points = self._hotspot_rect_points(self.hotspot_editor_drag_start, world)
        self.hotspot_editor_drag_start     = None
        self.hotspot_editor_preview_points = []
        x, y, w, h = self._hotspot_bounds(points)
        if w < 8 or h < 8:
            return
        name = self._next_hotspot_name()
        self.hotspots[name] = HotspotArea(
            name=name, points=points, target=self.hotspot_editor_default_target
        )
        self.hotspot_editor_selected = name
        self.hotspot_hovered         = name
        self._print_hotspot_snippet(name)
        self._auto_sync_script_block()


    def _draw_hotspot_editor(self):
        cdef str mode = self.hotspot_editor_mode
        cdef object panel = pygame.Surface((self.screen.get_width(), 74), pygame.SRCALPHA)
        panel.fill((8, 8, 10, 185))
        self.screen.blit(panel, (0, 0))

        cdef object title_surf = self.inspector_font.render(
            "Hotspot Editor (F4): 1 Select  2 Rect  3 Poly  Enter finish poly  C copy  T target  Del remove",
            True, (240, 240, 240),
        )
        self.screen.blit(title_surf, (10, 8))
        cdef object title2_surf = self.inspector_font.render(
            "Arrow=move selected (Shift x10)  +/- zoom  Wheel zoom  R camera reset  Esc cancel/close",
            True, (210, 210, 210),
        )
        self.screen.blit(title2_surf, (10, 26))

        cdef list buttons = [
            ("mode_select", "Select",   mode == "select"),
            ("mode_rect",   "Rect",     mode == "rect"),
            ("mode_poly",   "Poly",     mode == "poly"),
            ("poly_done",   "PolyDone", False),
            ("copy",        "Copy",     False),
            ("delete",      "Delete",   False),
            ("clear",       "Clear",    False),
        ]
        self.hotspot_editor_buttons = {}
        cdef int x = 10, y = 46, bw
        cdef str key, label
        cdef bint active
        cdef object rect, color, txt
        for key, label, active in buttons:
            bw   = 88 if key == "poly_done" else 74
            rect = pygame.Rect(x, y, bw, 22)
            self.hotspot_editor_buttons[key] = rect
            color = (80, 170, 255) if active else (70, 70, 80)
            pygame.draw.rect(self.screen, color, rect, border_radius=4)
            pygame.draw.rect(self.screen, (220, 220, 220), rect, 1, border_radius=4)
            txt = self.inspector_font.render(label, True, (245, 245, 245))
            self.screen.blit(txt, (rect.x + 6, rect.y + 3))
            x += bw + 6

        cdef str selected = self.hotspot_editor_selected or "-"
        cdef str hovered  = self.hotspot_hovered or "-"
        cdef str status   = f"selected: {selected} | hovered: {hovered} | hotspots: {len(self.hotspots)}"
        cdef object status_surf = self.inspector_font.render(status, True, (230, 230, 150))
        self.screen.blit(status_surf, (x + 8, y + 3))

        cdef list screen_pts
        if mode == "rect" and self.hotspot_editor_preview_points:
            screen_pts = [self._bg_world_to_screen(pt) for pt in self.hotspot_editor_preview_points]
            pygame.draw.polygon(self.screen, (255, 255, 120, 40), screen_pts)
            pygame.draw.polygon(self.screen, (255, 255, 120),     screen_pts, 2)

        cdef int px, py
        if mode == "poly" and self.hotspot_editor_poly_points:
            screen_pts = [self._bg_world_to_screen(pt) for pt in self.hotspot_editor_poly_points]
            if len(screen_pts) >= 2:
                pygame.draw.lines(self.screen, (255, 210, 90), False, screen_pts, 2)
            for px, py in screen_pts:
                pygame.draw.circle(self.screen, (255, 230, 110), (<int>px, <int>py), 4)

    #  HUD Editor 

    def _toggle_hud_editor(self):
        self.show_hud_editor = not self.show_hud_editor
        if self.show_hud_editor:
            self.show_inspector              = False
            self.show_hotspot_editor          = False
            self.inspector_selected          = None
            self.inspector_dragging          = False
            self.inspector_resizing          = False
            self.inspector_resize_handle     = None
            self.inspector_resize_start_rect = None
            self.inspector_asset_mode        = False
            self.inspector_asset_buttons     = {}
            self.hud_editor_mode             = "select"
            self.hud_editor_drag_start       = None
            self.hud_editor_preview_rect     = None
            self.hud_editor_buttons          = {}
        else:
            self.hud_editor_drag_start   = None
            self.hud_editor_preview_rect = None
            self.hud_editor_buttons      = {}
            self.hud_hovered             = None

    def _cancel_hud_editor_action(self):
        if not self.show_hud_editor:
            return False
        if self.hud_editor_drag_start is not None:
            self.hud_editor_drag_start   = None
            self.hud_editor_preview_rect = None
            return True
        self._toggle_hud_editor()
        return True

    def _set_hud_editor_mode(self, str mode):
        if mode not in {"select", "rect"}:
            return
        self.hud_editor_mode         = mode
        self.hud_editor_drag_start   = None
        self.hud_editor_preview_rect = None

    def _cycle_hud_editor_mode(self):
        cdef list order = ["select", "rect"]
        cdef int idx
        try:
            idx = order.index(self.hud_editor_mode)
        except ValueError:
            idx = 0
        self._set_hud_editor_mode(order[(idx + 1) % 2])

    def _next_hud_name(self):
        cdef int idx = 1
        cdef str name
        while True:
            name = f"hud_{idx}"
            if name not in self.hud_buttons:
                return name
            idx += 1

    def _hud_snippet(self, object btn):
        if btn.style == "both" and btn.icon_path and btn.text:
            return (f'hud add {btn.name} both "{btn.icon_path}" "{btn.text}" '
                    f'{btn.rect.x} {btn.rect.y} {btn.rect.width} {btn.rect.height} '
                    f'-> {btn.target};')
        if btn.style == "icon" and btn.icon_path:
            return (f'hud add {btn.name} icon "{btn.icon_path}" '
                    f'{btn.rect.x} {btn.rect.y} {btn.rect.width} {btn.rect.height} '
                    f'-> {btn.target};')
        return (f'hud add {btn.name} text "{btn.text or "Button"}" '
                f'{btn.rect.x} {btn.rect.y} {btn.rect.width} {btn.rect.height} '
                f'-> {btn.target};')

    def _print_hud_snippet(self, str name):
        pass

    def _print_all_hud_snippets(self):
        pass

    def _shift_hud(self, str name, int dx, int dy):
        cdef object btn = self.hud_buttons.get(name)
        if btn is None:
            return
        btn.rect.x += dx
        btn.rect.y += dy
        self._auto_sync_script_block()

    def _cycle_hud_target(self, str name):
        cdef object btn = self.hud_buttons.get(name)
        if btn is None or not self.labels:
            return
        cdef list label_names = sorted(self.labels.keys())
        cdef int next_idx
        if btn.target in label_names:
            next_idx = (label_names.index(btn.target) + 1) % len(label_names)
        else:
            next_idx = 0
        btn.target = label_names[next_idx]
        self._print_hud_snippet(name)
        self._auto_sync_script_block()

    def _hud_editor_button_at(self, tuple pos):
        cdef str name
        cdef object rect
        for name, rect in self.hud_editor_buttons.items():
            if rect.collidepoint(pos):
                return name
        return None

    def _handle_hud_editor_keydown(self, object event):
        cdef int key  = event.key
        cdef int mods = pygame.key.get_mods()
        cdef int step = 10 if (mods & pygame.KMOD_SHIFT) else 1

        if key == pygame.K_TAB:
            self._cycle_hud_editor_mode(); return
        if key in (pygame.K_1, pygame.K_KP1):
            self._set_hud_editor_mode("select"); return
        if key in (pygame.K_2, pygame.K_KP2):
            self._set_hud_editor_mode("rect"); return
        if key in (pygame.K_BACKSPACE, pygame.K_DELETE):
            if self.hud_editor_selected:
                self.hud_buttons.pop(self.hud_editor_selected, None)
                self.hud_editor_selected = None
                self.hud_hovered         = None
                self._auto_sync_script_block()
            return
        if key == pygame.K_c:
            if self.hud_editor_selected:
                self._print_hud_snippet(self.hud_editor_selected)
            return
        if key == pygame.K_p:
            self._print_all_hud_snippets(); return
        if key == pygame.K_t and self.hud_editor_selected:
            self._cycle_hud_target(self.hud_editor_selected); return

        if key == pygame.K_LEFT:
            if self.hud_editor_selected: self._shift_hud(self.hud_editor_selected, -step, 0)
            return
        if key == pygame.K_RIGHT:
            if self.hud_editor_selected: self._shift_hud(self.hud_editor_selected, step, 0)
            return
        if key == pygame.K_UP:
            if self.hud_editor_selected: self._shift_hud(self.hud_editor_selected, 0, -step)
            return
        if key == pygame.K_DOWN:
            if self.hud_editor_selected: self._shift_hud(self.hud_editor_selected, 0, step)
            return

    def _handle_hud_editor_mousedown(self, object event):
        cdef tuple pos = event.pos
        cdef object action

        if event.button != 1:
            return

        action = self._hud_editor_button_at(pos)
        if action:
            if action == "mode_select":  self._set_hud_editor_mode("select")
            elif action == "mode_rect":  self._set_hud_editor_mode("rect")
            elif action == "copy":
                if self.hud_editor_selected:
                    self._print_hud_snippet(self.hud_editor_selected)
            elif action == "delete":
                if self.hud_editor_selected:
                    self.hud_buttons.pop(self.hud_editor_selected, None)
                    self.hud_hovered         = None
                    self.hud_editor_selected = None
                    self._auto_sync_script_block()
            elif action == "clear":
                self.hud_buttons.clear()
                self.hud_hovered             = None
                self.hud_editor_selected     = None
                self.hud_editor_drag_start   = None
                self.hud_editor_preview_rect = None
                self._auto_sync_script_block()
            return

        if self.hud_editor_mode == "select":
            found = None
            for btn in self.hud_buttons.values():
                if btn.rect.collidepoint(pos):
                    found = btn.name
            self.hud_editor_selected = found
            self.hud_hovered         = found
            if found is not None:
                btn = self.hud_buttons[found]
                self.hud_editor_dragging    = True
                self.hud_editor_drag_offset = (pos[0] - btn.rect.x, pos[1] - btn.rect.y)
            return

        if self.hud_editor_mode == "rect":
            self.hud_editor_drag_start = pos
            self.hud_editor_preview_rect = (pos[0], pos[1], 0, 0)
            return

    def _handle_hud_editor_mousemotion(self, object event):
        cdef object btn
        if self.hud_editor_mode == "select" and self.hud_editor_dragging and self.hud_editor_selected:
            btn = self.hud_buttons.get(self.hud_editor_selected)
            if btn is not None:
                ox, oy = self.hud_editor_drag_offset
                btn.rect.x = event.pos[0] - ox
                btn.rect.y = event.pos[1] - oy
            return
        if self.hud_editor_mode == "rect" and self.hud_editor_drag_start is not None:
            sx, sy = self.hud_editor_drag_start
            ex, ey = event.pos
            x = min(sx, ex)
            y = min(sy, ey)
            w = abs(ex - sx)
            h = abs(ey - sy)
            self.hud_editor_preview_rect = (x, y, w, h)
            return
        found = None
        for btn in self.hud_buttons.values():
            if btn.rect.collidepoint(event.pos):
                found = btn.name
        self.hud_hovered = found

    def _handle_hud_editor_mouseup(self, object event):
        cdef int x, y, w, h
        cdef str name

        if event.button != 1:
            return
        if self.hud_editor_mode == "select" and self.hud_editor_dragging:
            self.hud_editor_dragging = False
            self._auto_sync_script_block()
            return
        if self.hud_editor_mode != "rect" or self.hud_editor_drag_start is None:
            return
        sx, sy = self.hud_editor_drag_start
        ex, ey = event.pos
        x = min(sx, ex)
        y = min(sy, ey)
        w = abs(ex - sx)
        h = abs(ey - sy)
        self.hud_editor_drag_start   = None
        self.hud_editor_preview_rect = None
        if w < 16 or h < 12:
            return
        name = self._next_hud_name()
        self.hud_buttons[name] = HudButton(
            name=name,
            style="text",
            text=self.hud_editor_default_text,
            icon_path=None,
            icon_surface=None,
            rect=pygame.Rect(x, y, w, h),
            target=self.hud_editor_default_target,
        )
        self.hud_editor_selected = name
        self.hud_hovered         = name
        self._print_hud_snippet(name)
        self._auto_sync_script_block()
